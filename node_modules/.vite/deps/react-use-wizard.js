import {
  require_react
} from "./chunk-OFVOUQQ6.js";
import {
  __toESM
} from "./chunk-VHXUCOYC.js";

// node_modules/react-use-wizard/dist/react-use-wizard.mjs
var import_react = __toESM(require_react(), 1);
var WizardContext = (0, import_react.createContext)(null);
if (true) {
  WizardContext.displayName = "WizardContext";
}
var useWizard = () => {
  const context = (0, import_react.useContext)(WizardContext);
  if (!context && true) {
    throw Error("Wrap your step with `Wizard`");
  } else {
    return context;
  }
};
var log = (level, message) => {
  if (true) {
    const packageName = "[react-use-wizard]";
    switch (level) {
      case "warn":
        console.warn(packageName + " " + message);
        break;
      case "error":
        console.error(packageName + " " + message);
        break;
      default:
        console.log(packageName + " " + message);
    }
  }
};
var Wizard = (0, import_react.memo)(({
  header,
  footer,
  children,
  onStepChange,
  wrapper: Wrapper,
  startIndex = 0
}) => {
  const [activeStep, setActiveStep] = (0, import_react.useState)(startIndex);
  const [isLoading, setIsLoading] = (0, import_react.useState)(false);
  const hasNextStep = (0, import_react.useRef)(true);
  const hasPreviousStep = (0, import_react.useRef)(false);
  const nextStepHandler = (0, import_react.useRef)(() => {
  });
  const stepCount = import_react.Children.toArray(children).length;
  hasNextStep.current = activeStep < stepCount - 1;
  hasPreviousStep.current = activeStep > 0;
  const goToNextStep = (0, import_react.useCallback)(() => {
    if (hasNextStep.current) {
      const newActiveStepIndex = activeStep + 1;
      setActiveStep(newActiveStepIndex);
      onStepChange == null ? void 0 : onStepChange(newActiveStepIndex);
    }
  }, [activeStep, onStepChange]);
  const goToPreviousStep = (0, import_react.useCallback)(() => {
    if (hasPreviousStep.current) {
      nextStepHandler.current = null;
      const newActiveStepIndex = activeStep - 1;
      setActiveStep(newActiveStepIndex);
      onStepChange == null ? void 0 : onStepChange(newActiveStepIndex);
    }
  }, [activeStep, onStepChange]);
  const goToStep = (0, import_react.useCallback)((stepIndex) => {
    if (stepIndex >= 0 && stepIndex < stepCount) {
      nextStepHandler.current = null;
      setActiveStep(stepIndex);
      onStepChange == null ? void 0 : onStepChange(stepIndex);
    } else {
      if (true) {
        log("warn", ["Invalid step index [" + stepIndex + "] passed to 'goToStep'. ", "Ensure the given stepIndex is not out of boundaries."].join(""));
      }
    }
  }, [stepCount, onStepChange]);
  const handleStep = (0, import_react.useRef)((handler) => {
    nextStepHandler.current = handler;
  });
  const doNextStep = (0, import_react.useCallback)(async () => {
    if (hasNextStep.current && nextStepHandler.current) {
      try {
        setIsLoading(true);
        await nextStepHandler.current();
        setIsLoading(false);
        nextStepHandler.current = null;
        goToNextStep();
      } catch (error) {
        setIsLoading(false);
        throw error;
      }
    } else {
      goToNextStep();
    }
  }, [goToNextStep]);
  const wizardValue = (0, import_react.useMemo)(() => ({
    nextStep: doNextStep,
    previousStep: goToPreviousStep,
    handleStep: handleStep.current,
    isLoading,
    activeStep,
    stepCount,
    isFirstStep: !hasPreviousStep.current,
    isLastStep: !hasNextStep.current,
    goToStep
  }), [doNextStep, goToPreviousStep, isLoading, activeStep, stepCount, goToStep]);
  const activeStepContent = (0, import_react.useMemo)(() => {
    const reactChildren = import_react.Children.toArray(children);
    if (true) {
      if (reactChildren.length === 0) {
        log("warn", "Make sure to pass your steps as children in your <Wizard>");
      }
      if (activeStep > reactChildren.length) {
        log("warn", "An invalid startIndex is passed to <Wizard>");
      }
      if (header && !(0, import_react.isValidElement)(header)) {
        log("error", "Invalid header passed to <Wizard>");
      }
      if (footer && !(0, import_react.isValidElement)(footer)) {
        log("error", "Invalid footer passed to <Wizard>");
      }
    }
    return reactChildren[activeStep];
  }, [activeStep, children, header, footer]);
  const enhancedActiveStepContent = (0, import_react.useMemo)(() => Wrapper ? (0, import_react.cloneElement)(Wrapper, {
    children: activeStepContent
  }) : activeStepContent, [Wrapper, activeStepContent]);
  return (0, import_react.createElement)(WizardContext.Provider, {
    value: wizardValue
  }, header, enhancedActiveStepContent, footer);
});
export {
  Wizard,
  useWizard
};
//# sourceMappingURL=react-use-wizard.js.map
