import {
  require_client
} from "./chunk-S7GJYO3C.js";
import {
  require_jsx_runtime
} from "./chunk-7QHU65CW.js";
import "./chunk-RXSXIAHT.js";
import {
  require_react
} from "./chunk-OFVOUQQ6.js";
import {
  __toESM
} from "./chunk-VHXUCOYC.js";

// node_modules/datatables.net-react/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_client = __toESM(require_client(), 1);
var import_react = __toESM(require_react(), 1);
var dtEvents = [
  "autoFill",
  "preAutoFill",
  "buttons-action",
  "buttons-processing",
  "column-reorder",
  "columns-reordered",
  "childRow",
  "column-sizing",
  "column-visibility",
  "destroy",
  "draw",
  "dt-error",
  "info",
  "init",
  "length",
  "options",
  "order",
  "page",
  "preDraw",
  "preInit",
  "preXhr",
  "processing",
  "requestChild",
  "search",
  "stateLoaded",
  "stateLoadParams",
  "stateSaveParams",
  "xhr",
  "key",
  "key-blur",
  "key-focus",
  "key-prefocus",
  "key-refocus",
  "key-return-submit",
  "responsive-display",
  "responsive-resize",
  "rowgroup-datasrc",
  "pre-row-reorder",
  "row-reorder",
  "row-reorder-canceled",
  "row-reorder-changed",
  "row-reordered",
  "dtsb-inserted",
  "deselect",
  "select",
  "select-blur",
  "selectItems",
  "selectStyle",
  "user-select",
  "stateRestore-change"
];
var DataTablesLib = null;
var Component = (0, import_react.forwardRef)(function DataTable(props, ref) {
  const tableEl = (0, import_react.useRef)(null);
  const table = (0, import_react.useRef)(null);
  const options = (0, import_react.useRef)(props.options ?? {});
  const cache = (0, import_react.useRef)([]);
  (0, import_react.useImperativeHandle)(ref, () => ({
    dt: () => table.current
  }));
  if (props.data) {
    options.current.data = props.data;
  }
  if (props.ajax) {
    options.current.ajax = props.ajax;
  }
  if (props.columns) {
    options.current.columns = props.columns;
  }
  if (props.slots) {
    applySlots(cache.current, options.current, props.slots);
  }
  (0, import_react.useEffect)(() => {
    if (!DataTablesLib) {
      throw new Error("DataTables library not set. See https://datatables.net/tn/23 for details.");
    }
    if (tableEl.current) {
      const $ = DataTablesLib.use("jq");
      const table$ = $(tableEl.current);
      dtEvents.forEach((name) => {
        const onName = "on" + name[0].toUpperCase() + name.slice(1).replace(/-[a-z]/g, (match) => match[1].toUpperCase());
        if (props[onName]) {
          table$.on(name + ".dt", props[onName]);
        }
      });
      table.current = new DataTablesLib(tableEl.current, options.current);
    }
    return () => {
      if (table.current) {
        let roots = cache.current.slice();
        cache.current.length = 0;
        setTimeout(() => {
          roots.forEach((r) => {
            r.unmount();
          });
        }, 250);
        table.current.destroy();
        table.current = null;
      }
    };
  }, []);
  (0, import_react.useEffect)(() => {
    if (props.data) {
      if (table.current) {
        table.current.clear();
        table.current.rows.add(props.data).draw(false);
      }
    }
  }, [props.data]);
  return (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)("table", { ref: tableEl, className: props.className ?? "", id: props.id ?? "", children: props.children ?? null }) });
});
Component.use = function(lib) {
  DataTablesLib = lib;
};
var Exporter = Component;
function applySlots(cache, options, slots) {
  if (!options.columnDefs) {
    options.columnDefs = [];
  }
  Object.keys(slots).forEach((name) => {
    let slot = slots[name];
    if (!slot) {
      return;
    }
    if (name.match(/^-?\d+$/)) {
      options.columnDefs.unshift({
        target: parseInt(name),
        render: slotRenderer(cache, slot)
      });
    } else {
      options.columnDefs.unshift({
        target: name + ":name",
        render: slotRenderer(cache, slot)
      });
    }
  });
}
function slotRenderer(cache, slot) {
  return function(data, type, row, meta) {
    if (slot.length === 4) {
      let result = slot(data, type, row, meta);
      return result["$$typeof"] ? renderJsx(cache, result) : result;
    } else if (slot.length === 3) {
      let result = slot(data, type, row, meta);
      return result["$$typeof"] ? renderJsx(cache, result) : result;
    }
    return slotCache(cache, () => slot(data, row));
  };
}
function slotCache(cache, create) {
  let result = create();
  if (result["$$typeof"]) {
    let div = renderJsx(cache, result);
    return div;
  }
  return result;
}
function renderJsx(cache, jsx2) {
  let div = document.createElement("div");
  let root = (0, import_client.createRoot)(div);
  root.render(jsx2);
  cache.push(root);
  return div;
}
export {
  Exporter as default
};
//# sourceMappingURL=datatables__net-react.js.map
