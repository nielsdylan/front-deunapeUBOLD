{"version":3,"file":"trie-memoize.js","sources":["../../src/index.ts"],"sourcesContent":["export interface MapLike {\n  new (...args: any[]): any\n}\n\nexport type CacheConstructor =\n  | MapConstructor\n  | WeakMapConstructor\n  | MapLike\n  | Record<any, any>\n\ninterface Cache<K = any, V = any> {\n  set: (k: K, v: V) => V\n  get: (k: K) => V\n}\n\nconst createCache = (obj: CacheConstructor): Cache => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache: Record<string, any> = {}\n\n    return {\n      set(k, v): void {\n        cache[k] = v\n      },\n      get(k): any {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (\n  constructors: CacheConstructor[]\n): {s: Cache['set']; g: Cache['get']} => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base: any\n  let map: any\n  let i: number\n  let node: typeof baseCache\n  const one = depth === 1\n  // quicker access for one and two-argument functions\n  const g1 = (args: IArguments): any =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n  const s1 = (args: IArguments, value: any): any => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n\n    return value\n  }\n\n  const g2 = (args: IArguments): any => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args: IArguments, value: any): any => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3 ? {g: g1, s: s1} : {g: g2, s: s2}\n}\n\nconst memoize = <T extends any[], U extends any>(\n  mapConstructors: CacheConstructor[],\n  fn: (...args: T) => U\n): ((...args: T) => U) => {\n  let item: U\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments as any))\n      : item\n  }\n}\n\nexport default memoize\n"],"names":["createCache","obj","e","cache","set","k","v","get","mapConstructors","fn","item","constructors","base","map","i","node","depth","baseCache","one","length","g","args","s","value","arguments","apply"],"mappings":"kMAeA,IAAMA,EAAc,SAACC,cAGV,IAAIA,EACX,MAAOC,OACDC,EAA6B,SAE5B,CACLC,aAAIC,EAAGC,GACLH,EAAME,GAAKC,GAEbC,aAAIF,UACKF,EAAME,cA+DL,SACdG,EACAC,OAEIC,EA5DJC,EAIIC,EACAC,EACAC,EACAC,EALEC,EACJC,EAKIC,KANAF,GAFNL,EA6DoBH,GA3DOW,OACzBF,EAAYjB,EAAYW,EAAa,IAKjCO,EAAgB,IAAVF,EA6CG,EAARA,EAAY,CAACI,EA3CT,SAACC,eAC0B,KAAnCT,EAAOK,EAAUV,IAAIc,EAAK,MAAmBH,EAAMN,EAAOA,EAAKL,IAAIc,EAAK,KA0ChDC,EAzChB,SAACD,EAAkBE,UACxBL,EAAKD,EAAUb,IAAIiB,EAAK,GAAIE,QAEU,KAAnCX,EAAOK,EAAUV,IAAIc,EAAK,OAC7BR,EAAMb,EAAYW,EAAa,KAC3BP,IAAIiB,EAAK,GAAIE,GACjBN,EAAUb,IAAIiB,EAAK,GAAIR,IAEvBD,EAAKR,IAAIiB,EAAK,GAAIE,GAIfA,IA6B2B,CAACH,EA1B1B,SAACC,OACVN,EAAOE,EAEFH,EAAI,EAAOE,EAAJF,EAAWA,YACc,KAA9BC,EAAOA,EAAKR,IAAIc,EAAKP,KAAiB,cAEtCC,GAoBmCO,EAjBjC,SAACD,EAAkBE,OAC5BR,EAAOE,EAEFH,EAAI,EAAOE,EAAQ,EAAZF,EAAeA,SACS,KAA7BD,EAAME,EAAKR,IAAIc,EAAKP,MACvBD,EAAMb,EAAYW,EAAaG,EAAI,IACnCC,EAAKX,IAAIiB,EAAKP,GAAID,GAClBE,EAAOF,GAEPE,EAAOF,SAIXE,EAAKX,IAAIiB,EAAKL,EAAQ,GAAIO,GACnBA,KAWFH,IAAAA,EAAGE,IAAAA,SACH,uBAC4B,KAAzBZ,EAAOU,EAAEI,YACbF,EAAEE,UAAWf,EAAGgB,MAAM,KAAMD,YAC5Bd"}